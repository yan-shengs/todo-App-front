# 前端全栈技术学习路线图 - 从入门到精通

## 📋 学习路线概览

```
🌱 基础阶段 (1-3个月)     → HTML/CSS/JavaScript 基础
🌿 进阶阶段 (3-6个月)     → Vue.js + 现代前端工具链
🌳 实战阶段 (6-12个月)    → 全栈开发 + 项目实战
🏗️ 高级阶段 (12-18个月)   → 架构设计 + 性能优化
🚀 精通阶段 (18个月+)     → 技术深度 + 团队协作
```

## 🎯 第一阶段：前端基础 (1-3个月)

### 1.1 HTML基础与语义化 (2周)

#### 学习目标
- 掌握HTML5语义化标签
- 理解文档结构和accessibility
- 学会表单处理和验证

#### 学习内容
```html
<!-- 语义化HTML结构示例 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>语义化页面结构</title>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#home">首页</a></li>
                <li><a href="#about">关于</a></li>
            </ul>
        </nav>
    </header>
    
    <main>
        <article>
            <header>
                <h1>文章标题</h1>
                <time datetime="2024-01-01">2024年1月1日</time>
            </header>
            <section>
                <p>文章内容...</p>
            </section>
        </article>
        
        <aside>
            <section>
                <h2>相关推荐</h2>
                <ul>
                    <li><a href="#">推荐文章1</a></li>
                </ul>
            </section>
        </aside>
    </main>
    
    <footer>
        <p>&copy; 2024 网站版权</p>
    </footer>
</body>
</html>
```

#### 实践项目
- 创建个人简历页面
- 制作博客文章页面
- 实现表单收集页面

#### 学习资源
- [MDN HTML教程](https://developer.mozilla.org/zh-CN/docs/Web/HTML)
- [HTML5语义化最佳实践](https://www.w3.org/WAI/WCAG21/Understanding/)

### 1.2 CSS基础与布局 (3周)

#### 学习目标
- 掌握CSS选择器和样式优先级
- 学会Flexbox和Grid布局
- 理解响应式设计原理

#### 学习内容
```css
/* CSS基础到高级示例 */

/* 1. 基础选择器和样式 */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

/* 2. Flexbox布局 */
.flex-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
}

/* 3. Grid布局 */
.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

/* 4. 响应式设计 */
@media (max-width: 768px) {
    .container {
        padding: 0 16px;
    }
    
    .flex-container {
        flex-direction: column;
    }
}

/* 5. CSS变量和主题 */
:root {
    --primary-color: #007bff;
    --secondary-color: #6c757d;
    --font-size-base: 16px;
    --border-radius: 8px;
}

.theme-dark {
    --primary-color: #0d6efd;
    --bg-color: #212529;
}

/* 6. 动画和过渡 */
.button {
    background: var(--primary-color);
    border-radius: var(--border-radius);
    transition: all 0.3s ease;
    transform: translateY(0);
}

.button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.fade-in {
    animation: fadeInUp 0.6s ease forwards;
}
```

#### 实践项目
- 重构简历页面样式
- 创建响应式导航菜单
- 实现CSS动画效果集合

#### 学习资源
- [CSS Grid完整指南](https://css-tricks.com/snippets/css/complete-guide-grid/)
- [Flexbox完整指南](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

### 1.3 JavaScript基础 (4周)

#### 学习目标
- 掌握ES6+语法特性
- 理解异步编程(Promise/async-await)
- 学会DOM操作和事件处理

#### 学习内容
```javascript
// JavaScript基础到高级示例

// 1. ES6+基础语法
const user = {
    name: 'John',
    age: 25,
    email: 'john@example.com'
}

// 解构赋值
const { name, age, ...rest } = user
const [first, second] = ['apple', 'banana']

// 箭头函数和默认参数
const greet = (name = 'World') => `Hello, ${name}!`

// 模板字符串
const message = `用户 ${name} 今年 ${age} 岁`

// 2. 数组高阶函数
const numbers = [1, 2, 3, 4, 5]

const doubled = numbers.map(n => n * 2)
const evens = numbers.filter(n => n % 2 === 0)
const sum = numbers.reduce((acc, n) => acc + n, 0)

// 3. Promise和异步编程
// Promise基础
function fetchUser(id) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (id > 0) {
                resolve({ id, name: `User ${id}` })
            } else {
                reject(new Error('Invalid user ID'))
            }
        }, 1000)
    })
}

// async/await
async function getUserData(id) {
    try {
        const user = await fetchUser(id)
        console.log('用户数据:', user)
        return user
    } catch (error) {
        console.error('获取用户失败:', error.message)
        throw error
    }
}

// 4. 类和面向对象
class TodoApp {
    constructor() {
        this.todos = []
        this.nextId = 1
    }
    
    addTodo(text) {
        const todo = {
            id: this.nextId++,
            text,
            completed: false,
            createdAt: new Date()
        }
        this.todos.push(todo)
        return todo
    }
    
    toggleTodo(id) {
        const todo = this.todos.find(t => t.id === id)
        if (todo) {
            todo.completed = !todo.completed
        }
        return todo
    }
    
    get activeTodos() {
        return this.todos.filter(t => !t.completed)
    }
    
    get completedTodos() {
        return this.todos.filter(t => t.completed)
    }
}

// 5. DOM操作和事件处理
class DOMHelper {
    static createElement(tag, className, textContent) {
        const element = document.createElement(tag)
        if (className) element.className = className
        if (textContent) element.textContent = textContent
        return element
    }
    
    static addEventDelegate(parent, selector, event, handler) {
        parent.addEventListener(event, (e) => {
            if (e.target.matches(selector)) {
                handler(e)
            }
        })
    }
}

// 使用示例
const app = new TodoApp()
const todoList = document.getElementById('todoList')

// 事件委托
DOMHelper.addEventDelegate(todoList, '.todo-item', 'click', (e) => {
    const id = parseInt(e.target.dataset.id)
    app.toggleTodo(id)
    renderTodos()
})

function renderTodos() {
    todoList.innerHTML = ''
    app.todos.forEach(todo => {
        const item = DOMHelper.createElement(
            'div', 
            `todo-item ${todo.completed ? 'completed' : ''}`,
            todo.text
        )
        item.dataset.id = todo.id
        todoList.appendChild(item)
    })
}

// 6. 模块化编程
// utils.js
export const formatDate = (date) => {
    return new Intl.DateTimeFormat('zh-CN').format(date)
}

export const debounce = (func, delay) => {
    let timeoutId
    return (...args) => {
        clearTimeout(timeoutId)
        timeoutId = setTimeout(() => func.apply(this, args), delay)
    }
}

// main.js
import { formatDate, debounce } from './utils.js'

const searchInput = document.getElementById('search')
const debouncedSearch = debounce((query) => {
    console.log('搜索:', query)
}, 300)

searchInput.addEventListener('input', (e) => {
    debouncedSearch(e.target.value)
})
```

#### 实践项目
- 完成一个TodoApp (原生JavaScript)
- 实现图片懒加载功能
- 创建简单的SPA路由系统

## 🚀 第二阶段：Vue.js与现代前端 (3-6个月)

### 2.1 Vue.js基础 (4周)

#### 学习目标
- 掌握Vue 3 Composition API
- 理解响应式原理和生命周期
- 学会组件通信和状态管理

#### 学习内容
```vue
<!-- Vue基础示例 -->
<template>
  <div class="todo-app">
    <!-- 添加todo -->
    <form @submit.prevent="addTodo" class="add-form">
      <input
        v-model="newTodo"
        placeholder="添加新任务..."
        class="todo-input"
      />
      <button type="submit" :disabled="!newTodo.trim()">
        添加
      </button>
    </form>

    <!-- 筛选器 -->
    <div class="filters">
      <button
        v-for="filter in filters"
        :key="filter.key"
        :class="{ active: activeFilter === filter.key }"
        @click="activeFilter = filter.key"
      >
        {{ filter.label }}
      </button>
    </div>

    <!-- todo列表 -->
    <TransitionGroup name="todo" tag="ul" class="todo-list">
      <li
        v-for="todo in filteredTodos"
        :key="todo.id"
        :class="{ completed: todo.completed }"
        class="todo-item"
      >
        <input
          type="checkbox"
          v-model="todo.completed"
          class="todo-checkbox"
        />
        <span class="todo-text">{{ todo.text }}</span>
        <button @click="removeTodo(todo.id)" class="remove-btn">
          删除
        </button>
      </li>
    </TransitionGroup>

    <!-- 统计信息 -->
    <div class="stats">
      <span>总计: {{ todos.length }}</span>
      <span>未完成: {{ activeTodos.length }}</span>
      <span>已完成: {{ completedTodos.length }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'

// 类型定义
interface Todo {
  id: number
  text: string
  completed: boolean
  createdAt: Date
}

interface Filter {
  key: string
  label: string
  filter: (todo: Todo) => boolean
}

// 响应式状态
const todos = ref<Todo[]>([])
const newTodo = ref('')
const activeFilter = ref('all')
const nextId = ref(1)

// 筛选器配置
const filters: Filter[] = [
  { key: 'all', label: '全部', filter: () => true },
  { key: 'active', label: '未完成', filter: (todo) => !todo.completed },
  { key: 'completed', label: '已完成', filter: (todo) => todo.completed }
]

// 计算属性
const filteredTodos = computed(() => {
  const currentFilter = filters.find(f => f.key === activeFilter.value)
  return currentFilter ? todos.value.filter(currentFilter.filter) : todos.value
})

const activeTodos = computed(() => todos.value.filter(t => !t.completed))
const completedTodos = computed(() => todos.value.filter(t => t.completed))

// 方法
function addTodo() {
  if (newTodo.value.trim()) {
    todos.value.push({
      id: nextId.value++,
      text: newTodo.value.trim(),
      completed: false,
      createdAt: new Date()
    })
    newTodo.value = ''
  }
}

function removeTodo(id: number) {
  const index = todos.value.findIndex(t => t.id === id)
  if (index > -1) {
    todos.value.splice(index, 1)
  }
}

// 侦听器 - 持久化存储
watch(
  todos,
  (newTodos) => {
    localStorage.setItem('todos', JSON.stringify(newTodos))
  },
  { deep: true }
)

// 初始化数据
const savedTodos = localStorage.getItem('todos')
if (savedTodos) {
  todos.value = JSON.parse(savedTodos)
  nextId.value = Math.max(...todos.value.map(t => t.id), 0) + 1
}
</script>

<style scoped>
.todo-app {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
}

.add-form {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.todo-input {
  flex: 1;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 16px;
}

.filters {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.filters button {
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: white;
  cursor: pointer;
}

.filters button.active {
  background: #007bff;
  color: white;
}

.todo-list {
  list-style: none;
  padding: 0;
}

.todo-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border: 1px solid #eee;
  border-radius: 6px;
  margin-bottom: 8px;
}

.todo-item.completed .todo-text {
  text-decoration: line-through;
  opacity: 0.6;
}

.todo-text {
  flex: 1;
}

.remove-btn {
  color: #dc3545;
  border: none;
  background: none;
  cursor: pointer;
}

.stats {
  display: flex;
  gap: 20px;
  margin-top: 20px;
  font-size: 14px;
  color: #666;
}

/* 过渡动画 */
.todo-enter-active,
.todo-leave-active {
  transition: all 0.3s ease;
}

.todo-enter-from {
  opacity: 0;
  transform: translateX(-30px);
}

.todo-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>
```

#### 进阶概念
```vue
<!-- 高级Vue概念示例 -->
<template>
  <div class="advanced-todo">
    <!-- 自定义指令 -->
    <input v-focus v-model="searchQuery" placeholder="搜索..." />
    
    <!-- 动态组件 -->
    <component :is="currentView" :todos="filteredTodos" />
    
    <!-- 异步组件 -->
    <Suspense>
      <template #default>
        <AsyncTodoStats :todos="todos" />
      </template>
      <template #fallback>
        <div>加载统计信息...</div>
      </template>
    </Suspense>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineAsyncComponent } from 'vue'
import { useTodos } from '@/composables/useTodos'
import { useSearch } from '@/composables/useSearch'

// 组合式函数
const { todos, addTodo, removeTodo } = useTodos()
const { searchQuery, filteredItems } = useSearch(todos)

// 异步组件
const AsyncTodoStats = defineAsyncComponent(() => import('./TodoStats.vue'))

// 动态组件
const currentView = ref('TodoList')

const filteredTodos = computed(() => filteredItems.value)

// 自定义指令
const vFocus = {
  mounted(el: HTMLElement) {
    el.focus()
  }
}
</script>
```

```typescript
// composables/useTodos.ts - 组合式函数
import { ref, watch } from 'vue'

export interface Todo {
  id: number
  text: string
  completed: boolean
  createdAt: Date
}

export function useTodos() {
  const todos = ref<Todo[]>([])
  const nextId = ref(1)

  // 添加todo
  function addTodo(text: string) {
    if (text.trim()) {
      todos.value.push({
        id: nextId.value++,
        text: text.trim(),
        completed: false,
        createdAt: new Date()
      })
    }
  }

  // 删除todo
  function removeTodo(id: number) {
    const index = todos.value.findIndex(t => t.id === id)
    if (index > -1) {
      todos.value.splice(index, 1)
    }
  }

  // 切换完成状态
  function toggleTodo(id: number) {
    const todo = todos.value.find(t => t.id === id)
    if (todo) {
      todo.completed = !todo.completed
    }
  }

  // 持久化
  watch(
    todos,
    (newTodos) => {
      localStorage.setItem('todos', JSON.stringify(newTodos))
    },
    { deep: true }
  )

  // 初始化
  const savedTodos = localStorage.getItem('todos')
  if (savedTodos) {
    todos.value = JSON.parse(savedTodos)
    nextId.value = Math.max(...todos.value.map(t => t.id), 0) + 1
  }

  return {
    todos,
    addTodo,
    removeTodo,
    toggleTodo
  }
}
```

### 2.2 Vue生态系统 (3周)

#### Vue Router
```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes = [
  {
    path: '/',
    component: () => import('@/layouts/DefaultLayout.vue'),
    children: [
      {
        path: '',
        name: 'Home',
        component: () => import('@/views/HomeView.vue')
      },
      {
        path: 'todos',
        name: 'Todos',
        component: () => import('@/views/TodosView.vue'),
        meta: { requiresAuth: true }
      }
    ]
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/LoginView.vue')
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 路由守卫
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
  } else {
    next()
  }
})

export default router
```

#### Pinia状态管理
```typescript
// stores/todos.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { todoService } from '@/services/todoService'
import type { Todo, CreateTodoRequest } from '@/types/todo'

export const useTodoStore = defineStore('todos', () => {
  // 状态
  const todos = ref<Todo[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)

  // 计算属性
  const activeTodos = computed(() => todos.value.filter(t => !t.completed))
  const completedTodos = computed(() => todos.value.filter(t => t.completed))
  const todoCount = computed(() => todos.value.length)

  // 操作
  async function fetchTodos() {
    loading.value = true
    error.value = null
    
    try {
      const response = await todoService.getTodos()
      todos.value = response.data
    } catch (err: any) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }

  async function addTodo(todoData: CreateTodoRequest) {
    try {
      const response = await todoService.createTodo(todoData)
      todos.value.push(response.data)
    } catch (err: any) {
      error.value = err.message
      throw err
    }
  }

  async function updateTodo(id: number, updates: Partial<Todo>) {
    try {
      const response = await todoService.updateTodo(id, updates)
      const index = todos.value.findIndex(t => t.id === id)
      if (index !== -1) {
        todos.value[index] = response.data
      }
    } catch (err: any) {
      error.value = err.message
      throw err
    }
  }

  async function deleteTodo(id: number) {
    try {
      await todoService.deleteTodo(id)
      todos.value = todos.value.filter(t => t.id !== id)
    } catch (err: any) {
      error.value = err.message
      throw err
    }
  }

  return {
    // 状态
    todos,
    loading,
    error,
    // 计算属性
    activeTodos,
    completedTodos,
    todoCount,
    // 操作
    fetchTodos,
    addTodo,
    updateTodo,
    deleteTodo
  }
})
```

### 2.3 构建工具与开发环境 (2周)

#### Vite配置
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@views': resolve(__dirname, 'src/views'),
      '@stores': resolve(__dirname, 'src/stores')
    }
  },
  
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  },
  
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ui: ['element-plus'],
          utils: ['lodash-es', 'dayjs']
        }
      }
    }
  },
  
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: '@import "@/styles/variables.scss";'
      }
    }
  }
})
```

#### ESLint和Prettier配置
```json
// .eslintrc.js
module.exports = {
  extends: [
    '@vue/eslint-config-typescript',
    '@vue/eslint-config-prettier'
  ],
  rules: {
    'vue/multi-word-component-names': 'off',
    '@typescript-eslint/no-unused-vars': 'error',
    'vue/no-unused-components': 'error'
  }
}

// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "printWidth": 100
}
```

## 🔥 第三阶段：全栈开发 (6-12个月)

### 3.1 Node.js后端开发 (6周)

#### Express.js基础
```javascript
// server.js - Express服务器
const express = require('express')
const cors = require('cors')
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')
const { body, validationResult } = require('express-validator')

const app = express()

// 中间件
app.use(express.json())
app.use(cors())

// 内存存储（实际项目使用数据库）
let users = []
let todos = []
let nextUserId = 1
let nextTodoId = 1

// JWT中间件
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]
  
  if (!token) {
    return res.status(401).json({ error: '需要访问令牌' })
  }
  
  jwt.verify(token, process.env.JWT_SECRET || 'secret', (err, user) => {
    if (err) {
      return res.status(403).json({ error: '无效令牌' })
    }
    req.user = user
    next()
  })
}

// 用户注册
app.post('/api/register', [
  body('username').isLength({ min: 3 }).withMessage('用户名至少3个字符'),
  body('email').isEmail().withMessage('请输入有效邮箱'),
  body('password').isLength({ min: 6 }).withMessage('密码至少6个字符')
], async (req, res) => {
  const errors = validationResult(req)
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() })
  }
  
  try {
    const { username, email, password } = req.body
    
    // 检查用户是否已存在
    const existingUser = users.find(u => u.email === email)
    if (existingUser) {
      return res.status(400).json({ error: '邮箱已被注册' })
    }
    
    // 加密密码
    const hashedPassword = await bcrypt.hash(password, 10)
    
    // 创建用户
    const user = {
      id: nextUserId++,
      username,
      email,
      password: hashedPassword,
      createdAt: new Date()
    }
    
    users.push(user)
    
    // 生成JWT
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'secret',
      { expiresIn: '24h' }
    )
    
    res.status(201).json({
      message: '注册成功',
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email
      }
    })
  } catch (error) {
    res.status(500).json({ error: '服务器错误' })
  }
})

// 用户登录
app.post('/api/login', [
  body('email').isEmail(),
  body('password').exists()
], async (req, res) => {
  try {
    const { email, password } = req.body
    
    // 查找用户
    const user = users.find(u => u.email === email)
    if (!user) {
      return res.status(400).json({ error: '邮箱或密码错误' })
    }
    
    // 验证密码
    const validPassword = await bcrypt.compare(password, user.password)
    if (!validPassword) {
      return res.status(400).json({ error: '邮箱或密码错误' })
    }
    
    // 生成JWT
    const token = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'secret',
      { expiresIn: '24h' }
    )
    
    res.json({
      message: '登录成功',
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email
      }
    })
  } catch (error) {
    res.status(500).json({ error: '服务器错误' })
  }
})

// 获取待办事项
app.get('/api/todos', authenticateToken, (req, res) => {
  const userTodos = todos.filter(todo => todo.userId === req.user.userId)
  res.json(userTodos)
})

// 创建待办事项
app.post('/api/todos', [
  authenticateToken,
  body('text').notEmpty().withMessage('待办事项内容不能为空')
], (req, res) => {
  const errors = validationResult(req)
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() })
  }
  
  const todo = {
    id: nextTodoId++,
    text: req.body.text,
    completed: false,
    userId: req.user.userId,
    createdAt: new Date()
  }
  
  todos.push(todo)
  res.status(201).json(todo)
})

// 更新待办事项
app.put('/api/todos/:id', authenticateToken, (req, res) => {
  const todoId = parseInt(req.params.id)
  const todo = todos.find(t => t.id === todoId && t.userId === req.user.userId)
  
  if (!todo) {
    return res.status(404).json({ error: '待办事项不存在' })
  }
  
  if (req.body.text !== undefined) {
    todo.text = req.body.text
  }
  
  if (req.body.completed !== undefined) {
    todo.completed = req.body.completed
  }
  
  todo.updatedAt = new Date()
  res.json(todo)
})

// 删除待办事项
app.delete('/api/todos/:id', authenticateToken, (req, res) => {
  const todoId = parseInt(req.params.id)
  const todoIndex = todos.findIndex(t => t.id === todoId && t.userId === req.user.userId)
  
  if (todoIndex === -1) {
    return res.status(404).json({ error: '待办事项不存在' })
  }
  
  todos.splice(todoIndex, 1)
  res.status(204).send()
})

// 错误处理中间件
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).json({ error: '服务器内部错误' })
})

const PORT = process.env.PORT || 3000
app.listen(PORT, () => {
  console.log(`服务器运行在端口 ${PORT}`)
})
```

### 3.2 数据库集成 (4周)

#### MongoDB + Mongoose
```javascript
// models/User.js
const mongoose = require('mongoose')
const bcrypt = require('bcrypt')

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    trim: true,
    minlength: 3,
    maxlength: 50
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    validate: {
      validator: function(v) {
        return /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(v)
      },
      message: '请输入有效的邮箱地址'
    }
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  avatar: {
    type: String,
    default: ''
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
})

// 密码加密中间件
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next()
  
  try {
    const salt = await bcrypt.genSalt(10)
    this.password = await bcrypt.hash(this.password, salt)
    next()
  } catch (error) {
    next(error)
  }
})

// 密码验证方法
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password)
}

// 转换为JSON时隐藏密码
userSchema.methods.toJSON = function() {
  const userObject = this.toObject()
  delete userObject.password
  return userObject
}

module.exports = mongoose.model('User', userSchema)
```

```javascript
// models/Todo.js
const mongoose = require('mongoose')

const todoSchema = new mongoose.Schema({
  text: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  completed: {
    type: Boolean,
    default: false
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high'],
    default: 'medium'
  },
  category: {
    type: String,
    default: '默认'
  },
  dueDate: {
    type: Date
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  tags: [{
    type: String,
    trim: true
  }]
}, {
  timestamps: true
})

// 索引优化
todoSchema.index({ user: 1, completed: 1 })
todoSchema.index({ user: 1, createdAt: -1 })

module.exports = mongoose.model('Todo', todoSchema)
```

```javascript
// controllers/todoController.js
const Todo = require('../models/Todo')
const { validationResult } = require('express-validator')

// 获取用户的待办事项
exports.getTodos = async (req, res) => {
  try {
    const { page = 1, limit = 10, completed, category, search } = req.query
    const filter = { user: req.user._id }
    
    // 构建查询条件
    if (completed !== undefined) {
      filter.completed = completed === 'true'
    }
    
    if (category && category !== 'all') {
      filter.category = category
    }
    
    if (search) {
      filter.text = { $regex: search, $options: 'i' }
    }
    
    // 分页查询
    const todos = await Todo.find(filter)
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .populate('user', 'username email')
    
    const total = await Todo.countDocuments(filter)
    
    res.json({
      todos,
      totalPages: Math.ceil(total / limit),
      currentPage: page,
      total
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// 创建待办事项
exports.createTodo = async (req, res) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() })
    }
    
    const todo = new Todo({
      ...req.body,
      user: req.user._id
    })
    
    await todo.save()
    await todo.populate('user', 'username email')
    
    res.status(201).json(todo)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// 更新待办事项
exports.updateTodo = async (req, res) => {
  try {
    const todo = await Todo.findOneAndUpdate(
      { _id: req.params.id, user: req.user._id },
      req.body,
      { new: true, runValidators: true }
    ).populate('user', 'username email')
    
    if (!todo) {
      return res.status(404).json({ error: '待办事项不存在' })
    }
    
    res.json(todo)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// 删除待办事项
exports.deleteTodo = async (req, res) => {
  try {
    const todo = await Todo.findOneAndDelete({
      _id: req.params.id,
      user: req.user._id
    })
    
    if (!todo) {
      return res.status(404).json({ error: '待办事项不存在' })
    }
    
    res.status(204).send()
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// 获取统计信息
exports.getStats = async (req, res) => {
  try {
    const userId = req.user._id
    
    const stats = await Todo.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          completed: {
            $sum: { $cond: [{ $eq: ['$completed', true] }, 1, 0] }
          },
          pending: {
            $sum: { $cond: [{ $eq: ['$completed', false] }, 1, 0] }
          }
        }
      }
    ])
    
    const categoryStats = await Todo.aggregate([
      { $match: { user: userId } },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 }
        }
      }
    ])
    
    res.json({
      overview: stats[0] || { total: 0, completed: 0, pending: 0 },
      categories: categoryStats
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}
```

### 3.3 RESTful API设计 (2周)

#### API设计原则和最佳实践
```javascript
// routes/api.js - REST API路由设计
const express = require('express')
const router = express.Router()
const { body, query, param } = require('express-validator')
const rateLimit = require('express-rate-limit')

// 限流中间件
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 最多100个请求
  message: { error: '请求过于频繁，请稍后再试' }
})

// API版本控制
router.use('/v1', limiter)

// =================== 用户相关API ===================

// GET /api/v1/users - 获取用户列表 (管理员)
router.get('/v1/users', [
  requireAuth,
  requireRole('admin'),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  query('search').optional().isLength({ max: 50 })
], getUsersController)

// GET /api/v1/users/:id - 获取用户详情
router.get('/v1/users/:id', [
  requireAuth,
  param('id').isMongoId()
], getUserController)

// PUT /api/v1/users/:id - 更新用户信息
router.put('/v1/users/:id', [
  requireAuth,
  param('id').isMongoId(),
  body('username').optional().isLength({ min: 3, max: 50 }),
  body('email').optional().isEmail(),
  body('avatar').optional().isURL()
], updateUserController)

// DELETE /api/v1/users/:id - 删除用户 (管理员或本人)
router.delete('/v1/users/:id', [
  requireAuth,
  param('id').isMongoId()
], deleteUserController)

// =================== 待办事项API ===================

// GET /api/v1/todos - 获取待办事项列表
router.get('/v1/todos', [
  requireAuth,
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  query('completed').optional().isBoolean(),
  query('category').optional().isLength({ max: 50 }),
  query('search').optional().isLength({ max: 100 }),
  query('sortBy').optional().isIn(['createdAt', 'updatedAt', 'dueDate']),
  query('sortOrder').optional().isIn(['asc', 'desc'])
], getTodosController)

// POST /api/v1/todos - 创建待办事项
router.post('/v1/todos', [
  requireAuth,
  body('text').notEmpty().isLength({ max: 200 }),
  body('category').optional().isLength({ max: 50 }),
  body('priority').optional().isIn(['low', 'medium', 'high']),
  body('dueDate').optional().isISO8601(),
  body('tags').optional().isArray({ max: 10 }),
  body('tags.*').optional().isLength({ max: 20 })
], createTodoController)

// GET /api/v1/todos/:id - 获取待办事项详情
router.get('/v1/todos/:id', [
  requireAuth,
  param('id').isMongoId()
], getTodoController)

// PUT /api/v1/todos/:id - 更新待办事项
router.put('/v1/todos/:id', [
  requireAuth,
  param('id').isMongoId(),
  body('text').optional().isLength({ max: 200 }),
  body('completed').optional().isBoolean(),
  body('category').optional().isLength({ max: 50 }),
  body('priority').optional().isIn(['low', 'medium', 'high']),
  body('dueDate').optional().isISO8601()
], updateTodoController)

// DELETE /api/v1/todos/:id - 删除待办事项
router.delete('/v1/todos/:id', [
  requireAuth,
  param('id').isMongoId()
], deleteTodoController)

// =================== 批量操作API ===================

// PUT /api/v1/todos/batch - 批量更新待办事项
router.put('/v1/todos/batch', [
  requireAuth,
  body('ids').isArray({ min: 1, max: 100 }),
  body('ids.*').isMongoId(),
  body('updates').isObject(),
  body('updates.completed').optional().isBoolean(),
  body('updates.category').optional().isLength({ max: 50 })
], batchUpdateTodosController)

// DELETE /api/v1/todos/batch - 批量删除待办事项
router.delete('/v1/todos/batch', [
  requireAuth,
  body('ids').isArray({ min: 1, max: 100 }),
  body('ids.*').isMongoId()
], batchDeleteTodosController)

// =================== 统计API ===================

// GET /api/v1/todos/stats - 获取待办事项统计
router.get('/v1/todos/stats', [
  requireAuth,
  query('period').optional().isIn(['week', 'month', 'year'])
], getTodoStatsController)

// =================== 导出API ===================

// GET /api/v1/todos/export - 导出待办事项
router.get('/v1/todos/export', [
  requireAuth,
  query('format').optional().isIn(['json', 'csv', 'pdf']),
  query('filter').optional().isJSON()
], exportTodosController)

module.exports = router
```

## 🏗️ 第四阶段：高级概念 (12-18个月)

### 4.1 性能优化 (4周)

#### 前端性能优化
```vue
<!-- 性能优化示例 -->
<template>
  <div class="optimized-app">
    <!-- 虚拟滚动 -->
    <RecycleScroller
      class="scroller"
      :items="items"
      :item-size="60"
      key-field="id"
      v-slot="{ item }"
    >
      <TodoItem :todo="item" />
    </RecycleScroller>
    
    <!-- 图片懒加载 -->
    <img
      v-lazy="imageUrl"
      :key="imageUrl"
      alt="图片描述"
    />
    
    <!-- 组件懒加载 -->
    <Suspense>
      <template #default>
        <AsyncHeavyComponent />
      </template>
      <template #fallback>
        <SkeletonLoader />
      </template>
    </Suspense>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineAsyncComponent } from 'vue'
import { RecycleScroller } from 'vue-virtual-scroller'
import { useLazyLoad } from '@/composables/useLazyLoad'
import { useInfiniteScroll } from '@/composables/useInfiniteScroll'

// 异步组件
const AsyncHeavyComponent = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: () => import('./ErrorComponent.vue'),
  loadingComponent: () => import('./LoadingComponent.vue')
})

// 无限滚动
const { items, loading, loadMore } = useInfiniteScroll(async (page) => {
  const response = await todoService.getTodos({ page, limit: 20 })
  return response.data
})

// 图片懒加载
const { imageUrl } = useLazyLoad()
</script>
```

```typescript
// composables/useInfiniteScroll.ts
import { ref, onMounted, onUnmounted } from 'vue'

export function useInfiniteScroll<T>(
  fetchFn: (page: number) => Promise<T[]>,
  options: {
    threshold?: number
    initialPage?: number
  } = {}
) {
  const items = ref<T[]>([])
  const loading = ref(false)
  const page = ref(options.initialPage || 1)
  const hasMore = ref(true)
  
  const loadMore = async () => {
    if (loading.value || !hasMore.value) return
    
    loading.value = true
    try {
      const newItems = await fetchFn(page.value)
      if (newItems.length === 0) {
        hasMore.value = false
      } else {
        items.value.push(...newItems)
        page.value++
      }
    } catch (error) {
      console.error('加载失败:', error)
    } finally {
      loading.value = false
    }
  }
  
  const handleScroll = () => {
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement
    const threshold = options.threshold || 100
    
    if (scrollHeight - scrollTop - clientHeight < threshold) {
      loadMore()
    }
  }
  
  onMounted(() => {
    loadMore()
    window.addEventListener('scroll', handleScroll)
  })
  
  onUnmounted(() => {
    window.removeEventListener('scroll', handleScroll)
  })
  
  return {
    items,
    loading,
    hasMore,
    loadMore
  }
}
```

#### 后端性能优化
```javascript
// 缓存策略
const Redis = require('redis')
const client = Redis.createClient()

// 缓存中间件
const cache = (duration = 300) => {
  return async (req, res, next) => {
    const key = `cache:${req.originalUrl}`
    
    try {
      const cached = await client.get(key)
      if (cached) {
        return res.json(JSON.parse(cached))
      }
    } catch (error) {
      console.error('缓存读取失败:', error)
    }
    
    // 重写res.json方法
    const originalJson = res.json
    res.json = function(data) {
      // 缓存响应数据
      client.setex(key, duration, JSON.stringify(data))
      return originalJson.call(this, data)
    }
    
    next()
  }
}

// 数据库查询优化
const getTodosOptimized = async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query
    
    // 使用索引优化查询
    const todos = await Todo.find({ user: req.user._id })
      .select('text completed category createdAt') // 只选择需要的字段
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .lean() // 返回普通JavaScript对象，提高性能
    
    // 并行查询总数
    const totalPromise = Todo.countDocuments({ user: req.user._id })
    const total = await totalPromise
    
    res.json({
      todos,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// 使用缓存
app.get('/api/todos', cache(300), getTodosOptimized)
```

### 4.2 测试策略 (3周)

#### 单元测试
```typescript
// tests/composables/useTodos.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { useTodos } from '@/composables/useTodos'
import { todoService } from '@/services/todoService'

// Mock API服务
vi.mock('@/services/todoService', () => ({
  todoService: {
    getTodos: vi.fn(),
    createTodo: vi.fn(),
    updateTodo: vi.fn(),
    deleteTodo: vi.fn()
  }
}))

describe('useTodos', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  
  it('should fetch todos on init', async () => {
    const mockTodos = [
      { id: 1, text: 'Test todo', completed: false }
    ]
    
    vi.mocked(todoService.getTodos).mockResolvedValue({
      data: mockTodos
    })
    
    const { todos, fetchTodos } = useTodos()
    
    await fetchTodos()
    
    expect(todoService.getTodos).toHaveBeenCalledOnce()
    expect(todos.value).toEqual(mockTodos)
  })
  
  it('should add new todo', async () => {
    const newTodo = { id: 2, text: 'New todo', completed: false }
    
    vi.mocked(todoService.createTodo).mockResolvedValue({
      data: newTodo
    })
    
    const { todos, addTodo } = useTodos()
    
    await addTodo('New todo')
    
    expect(todoService.createTodo).toHaveBeenCalledWith({ text: 'New todo' })
    expect(todos.value).toContain(newTodo)
  })
  
  it('should handle fetch error', async () => {
    const error = new Error('Network error')
    vi.mocked(todoService.getTodos).mockRejectedValue(error)
    
    const { error: todoError, fetchTodos } = useTodos()
    
    await fetchTodos()
    
    expect(todoError.value).toBe('Network error')
  })
})
```

#### 组件测试
```typescript
// tests/components/TodoItem.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import TodoItem from '@/components/TodoItem.vue'

describe('TodoItem', () => {
  const mockTodo = {
    id: 1,
    text: 'Test todo',
    completed: false
  }
  
  it('renders todo text correctly', () => {
    const wrapper = mount(TodoItem, {
      props: { todo: mockTodo }
    })
    
    expect(wrapper.text()).toContain('Test todo')
  })
  
  it('emits toggle event when checkbox clicked', async () => {
    const wrapper = mount(TodoItem, {
      props: { todo: mockTodo }
    })
    
    await wrapper.find('input[type="checkbox"]').trigger('change')
    
    expect(wrapper.emitted('toggle')).toBeTruthy()
    expect(wrapper.emitted('toggle')[0]).toEqual([1])
  })
  
  it('applies completed class when todo is completed', () => {
    const completedTodo = { ...mockTodo, completed: true }
    const wrapper = mount(TodoItem, {
      props: { todo: completedTodo }
    })
    
    expect(wrapper.classes()).toContain('completed')
  })
  
  it('emits delete event when delete button clicked', async () => {
    const wrapper = mount(TodoItem, {
      props: { todo: mockTodo }
    })
    
    await wrapper.find('.delete-btn').trigger('click')
    
    expect(wrapper.emitted('delete')).toBeTruthy()
    expect(wrapper.emitted('delete')[0]).toEqual([1])
  })
})
```

#### E2E测试
```typescript
// e2e/todo.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Todo App', () => {
  test.beforeEach(async ({ page }) => {
    // 登录
    await page.goto('/login')
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="login-btn"]')
    
    // 等待跳转到待办事项页面
    await expect(page).toHaveURL('/todos')
  })
  
  test('should add new todo', async ({ page }) => {
    const todoText = '测试新任务'
    
    // 添加新任务
    await page.fill('[data-testid="todo-input"]', todoText)
    await page.click('[data-testid="add-btn"]')
    
    // 验证任务是否添加
    await expect(page.locator('[data-testid="todo-item"]').last()).toContainText(todoText)
    
    // 验证输入框是否清空
    await expect(page.locator('[data-testid="todo-input"]')).toHaveValue('')
  })
  
  test('should toggle todo completion', async ({ page }) => {
    // 假设已有一个未完成的任务
    const todoItem = page.locator('[data-testid="todo-item"]').first()
    const checkbox = todoItem.locator('input[type="checkbox"]')
    
    // 标记为完成
    await checkbox.check()
    
    // 验证样式变化
    await expect(todoItem).toHaveClass(/completed/)
    
    // 取消完成
    await checkbox.uncheck()
    
    // 验证样式恢复
    await expect(todoItem).not.toHaveClass(/completed/)
  })
  
  test('should delete todo', async ({ page }) => {
    // 获取初始任务数量
    const initialCount = await page.locator('[data-testid="todo-item"]').count()
    
    // 删除第一个任务
    await page.locator('[data-testid="todo-item"]').first().locator('[data-testid="delete-btn"]').click()
    
    // 确认删除
    await page.click('[data-testid="confirm-btn"]')
    
    // 验证任务数量减少
    await expect(page.locator('[data-testid="todo-item"]')).toHaveCount(initialCount - 1)
  })
  
  test('should filter todos', async ({ page }) => {
    // 确保有已完成和未完成的任务
    await page.locator('[data-testid="todo-item"]').first().locator('input[type="checkbox"]').check()
    
    // 筛选已完成任务
    await page.click('[data-testid="filter-completed"]')
    
    // 验证只显示已完成任务
    const visibleTodos = page.locator('[data-testid="todo-item"]:visible')
    await expect(visibleTodos).toHaveClass(/completed/)
    
    // 筛选未完成任务
    await page.click('[data-testid="filter-active"]')
    
    // 验证只显示未完成任务
    await expect(visibleTodos).not.toHaveClass(/completed/)
  })
})
```

### 4.3 部署与DevOps (3周)

#### Docker容器化
```dockerfile
# Dockerfile - 前端
FROM node:18-alpine as build-stage

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine as production-stage

COPY --from=build-stage /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# Dockerfile - 后端
FROM node:18-alpine

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend
    environment:
      - VITE_API_URL=http://backend:3000/api

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    depends_on:
      - mongodb
      - redis
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongodb:27017/todoapp
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}

  mongodb:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_ROOT_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_ROOT_PASSWORD}

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend

volumes:
  mongodb_data:
  redis_data:
```

#### CI/CD流水线
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run type check
      run: npm run type-check
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run E2E tests
      run: npm run test:e2e
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build application
      run: npm run build
    
    - name: Build Docker image
      run: |
        docker build -t todoapp:${{ github.sha }} .
        docker tag todoapp:${{ github.sha }} todoapp:latest
    
    - name: Push to registry
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push todoapp:${{ github.sha }}
        docker push todoapp:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /opt/todoapp
          docker-compose pull
          docker-compose up -d
          docker image prune -f
```

## 🚀 第五阶段：精通与专业化 (18个月+)

### 5.1 微前端架构
### 5.2 性能监控与分析
### 5.3 团队协作与技术管理
### 5.4 开源贡献与技术分享

## 📚 学习资源推荐

### 官方文档
- [Vue.js 官方文档](https://vuejs.org/)
- [TypeScript 官方手册](https://www.typescriptlang.org/docs/)
- [Node.js 官方文档](https://nodejs.org/en/docs/)

### 在线课程
- [Vue Mastery](https://www.vuemastery.com/)
- [Frontend Masters](https://frontendmasters.com/)
- [慕课网](https://www.imooc.com/)

### 技术书籍
- 《Vue.js设计与实现》- 霍春阳
- 《JavaScript高级程序设计》- Matt Frisbie
- 《Node.js实战》- Mike Cantelon

### 实践项目建议
1. **个人博客系统** - Vue3 + Express + MongoDB
2. **在线商城** - Vue3 + Koa2 + MySQL
3. **实时聊天应用** - Vue3 + Socket.io + Redis
4. **数据分析面板** - Vue3 + D3.js + Python API
5. **移动端App** - Vue3 + Capacitor

## 🎯 学习建议与注意事项

### 学习节奏控制
- **不要贪多** - 每个阶段扎实掌握再进入下一阶段
- **项目驱动** - 每学一个技术点都要做实际项目练习
- **持续复习** - 定期回顾之前学过的内容

### 实践项目规划
- **第1-3个月** - 完成3-5个小项目
- **第3-6个月** - 完成1-2个中等项目
- **第6-12个月** - 完成1个大项目
- **第12个月+** - 参与开源项目或创建自己的开源项目

### 技能评估标准
每个阶段结束后进行自我评估：

#### 基础阶段评估
- [ ] 能够独立完成静态页面开发
- [ ] 熟练使用HTML5语义化标签
- [ ] 掌握CSS布局和响应式设计
- [ ] 能够用原生JavaScript实现交互功能

#### 进阶阶段评估
- [ ] 能够使用Vue3开发中等复杂度的SPA
- [ ] 理解组件化开发思想
- [ ] 熟练使用Vue生态系统
- [ ] 能够处理复杂的状态管理

#### 实战阶段评估
- [ ] 能够独立完成全栈项目
- [ ] 掌握API设计和数据库操作
- [ ] 理解项目部署和运维
- [ ] 具备代码质量意识

记住：学习编程是一个持续的过程，保持耐心和热情，多实践、多思考、多总结。每个人的学习节奏不同，找到适合自己的方式最重要！